
<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <title>clarete &mdash; Home</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="/media/css/main.css">
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
    <link rel="icon" type="image/png" href="/media/img/8bitme.png">
    <link rel="alternate" type="application/rss+xml" href="/blog/rss.xml">
  </head>
  <body>
    
      <div class="social">
        <div class="container">
          <ul class="badges">
            <li>
              <a href="mailto:lincoln@clarete.li" alt="Email">
                <span class="fa fa-envelope-o"></span>EMail
              </a>
            </li>
            <li>
              <a href="https://github.com/clarete" target="_blank" alt="Github">
                <span class="fa fa-github-alt"></span>Github
              </a>
            </li>
            <li>
              <a href="/blog/rss.xml" alt="RSS">
                <span class="fa fa-rss"></span>RSS
              </a>
            </li>
          </ul>

          <a href="/">
            <img class="avatar" type="image/svg+xml" src="/media/img/8bitme.svg" alt="Me in 8bit" />
          </a>
        </div>
      </div>
    

    <div class="post">
      <div class="container">
        
  <!-- toy-compiler-from-scratch -->
  
  <div class="title">
    <h1>A toy compiler from scratch</h1>
    <span class="pubdate">May 31, 2020</span>
  </div>

  
  <div class="content">
    <p>
I've always been fascinated with programming languages.  It's
incredible to me that some programs take the text representation of
our ideas and turn them into code that can be executed by the
computer.
</p>

<p>
Wanting to build my own programming languages, I started to write and
rewrite <a href="https://github.com/clarete/wheelbarrow/blob/master/lispinho/js/main.js">lots</a> <a href="https://github.com/clarete/yal">of</a> <a href="https://gist.github.com/clarete/03e825a70c4b4047468cc9d07ec47e4b">little</a> <a href="https://github.com/clarete/wheelbarrow/blob/master/lispinho/js/main2.js">lisp</a> interpreters. That is a common path for
beginners.  Making these toys gave me better understanding of how
programming languages work, but also made me a better software
engineer in general. So it's definitely worth the exercise :)
</p>

<p>
Today I want to share an exercise of designing <a href="https://github.com/clarete/effigy">Effigy</a>, a little toy
compiler that targets the Python Virtual Machine.  It's far away from
being a production level tool, but it's a bit fancier than the Lisp
interpreters I mentioned above.
</p>

<div class="note">
<p>
<b>Note</b>: Even though Python is said to be a scripting language, it does
have a <a href="https://github.com/python/cpython/blob/3.7/Python/ceval.c">virtual machine</a> that executes the <i>bytecode</i> generated by its
<a href="https://github.com/python/cpython/blob/3.7/Python/compile.c">compiler</a>.  This is where all those <code>.pyc</code> files come from! :)
</p>

</div>

<p>
Effigy takes a syntax that I made up and generates <i>bytecode</i> for that
Virtual Machine.  Without further ado, let's see how it works!
</p>

<div class="outline-2">
<h2 id="a-38k-feet-view-of-the-process">A 38k feet view of the process</h2>
<div class="outline-text-2">
<p>
The text representation of the program is parsed into a tree
structure that contains the meaning described in the text program.
That tree is traversed and the <i>bytecode</i> is emitted.
</p>

<div class="centralized">

<div id="org04c0889" class="figure">
<p><img src="../media/blogimg/effigy-an-experiment-writing-a-compiler-overview-mobile.png" alt="effigy-an-experiment-writing-a-compiler-overview-mobile.png" />
</p>
</div>

</div>

<p>
Because of its simplicity, Effigy doesn't really apply any
optimization to either the parse tree or to the <i>bytecode</i>.  That's
what keeps Effigy in the toy category.  At least it will make it
easier to understand how it works :)
</p>

<p>
Both the initial phase, that converts text into a parse tree, and
the second phase, that traverse the parse tree and emit code, are
built wit <a href="https://bford.info/pub/lang/peg.pdf">Parsing Expression Grammars</a> (or PEGs for short).  I
learned how to implement the tree scanning used in the second
transformation from the article <a href="http://www.lua.inf.puc-rio.br/publications/mascarenhas11parsing.pdf">Parsing Expression Grammars for
Structured Data</a>.  And during the time that I was implementing
Effigy, I also found the article <a href="http://www.vpri.org/pdf/tr2010003_PEG.pdf">PEG-based transformer provides
front-, middle and back-end stages in a simple compiler</a> that made me
feel more comfortable with my choice and made me tempted to re-write
the assembler as a PEG traversal too, but I never got to it.
</p>

<p>
Although it's not a requirement to understand this post, I highly
recommend reading the articles above as they were essential for me
to really understand how PEGs could be so flexible and powerful.
</p>
</div>
</div>

<div class="outline-2">
<h2 id="the-peg-library">The PEG library</h2>
<div class="outline-text-2">
<p>
Two out of the three of the main components of Effigy are built on
top of the PEG implementation.  That makes the PEG implementation
itself is a pretty important part of this project, so it's worth
talking about it with some depth before moving on to the actual
compiler.
</p>

<p>
The main goal of the PEG library is to parse input based on a
user-defined grammar and to capture the results when parsing
succeeds.  That happens in roughly three steps:
</p>

<ol class="org-ol">
<li>The user-defined grammar is parsed into a grammar tree;</li>
<li>The grammar tree and the input are fed to the grammar interpreter
that traverses the grammar tree and try to match the input.  If
matching is successful, it generates a parse tree with the
captured results;</li>
<li>The parse tree is traversed and semantic actions are applied;</li>
</ol>

<p>
The first step is a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a> that is able to
understand the syntax of PEG grammars and create a tree that is
traversed by the second step. E.g.: Parsing the grammar following
grammar:
</p>

<div class="org-src-container">
<pre class="src src-peg"><span class="org-function-name">Number</span> <span class="org-type">&lt;-</span> <span class="org-string">[0-9]</span><span class="org-builtin">+</span>
</pre>
</div>

<p>
yields the following grammar tree:
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-rainbow-delimiters-depth-1">{</span>
  Number: <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span>
    <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-rainbow-delimiters-depth-5">{</span> name: <span class="org-string">'oneOrMore'</span> <span class="org-rainbow-delimiters-depth-5">}</span>,
      <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-rainbow-delimiters-depth-6">{</span> name: <span class="org-string">'range'</span> <span class="org-rainbow-delimiters-depth-6">}</span>, <span class="org-string">'0'</span>, <span class="org-string">'9'</span><span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span>
  <span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
In that format, lists are considered lists unless their first item
is an object.  In that case, they're seen as functions and the rest
of the elements in the list are considered parameters.  That might
resemble Lisp's <a href="https://en.wikipedia.org/wiki/S-expression">S-Expressions</a> for some! This format is the simplest
I found to make the grammar interpreter as simple as possible as
well.
</p>

<p>
In the example above, the grammar interpreter starts from the first
rule of the grammar, <code>Number</code>, that triggers the function
<code>oneOrMore</code> with a <a href="https://en.wikipedia.org/wiki/Thunk">thunk</a> of <code>range</code> with its parameters and execute
it until it fails.
</p>

<p>
The grammar interpreter keeps the cursor of the input as an internal
field that increments when the character under the cursor matches
the piece of the grammar being executed. E.g.: If the above grammar
interpreter receives the above grammar and the input <code>123</code>, when
<code>oneOrMore</code> calls <code>range</code> for the first time, <code>cursor</code> is
incremented from <code>0</code> to <code>1</code>, when <code>oneOrMore</code> calls <code>range</code> again,
<code>cursor</code> is incremented from <code>1</code> to <code>2</code> and so forth.  Notice that
PEGs don't really need to consume the entire input to succeed.  If
you really want a grammar to enforce consuming the whole input to be
deemed successful, you can convey that need with the following
syntax:
</p>

<div class="org-src-container">
<pre class="src src-peg"><span class="org-function-name">Start</span>  <span class="org-type">&lt;-</span> Number <span class="org-builtin">!</span>.
<span class="org-function-name">Number</span> <span class="org-type">&lt;-</span> <span class="org-string">[0-9]</span><span class="org-builtin">+</span>
</pre>
</div>

<p>
The expression <code>!.</code> (or Not Any) only succeeds if <code>EOF</code> has been
reached.
</p>

<p>
The list of all operators available are the ones documented in
Ford's paper with the extension for parsing lists from Medeiros'
paper, and here they are:
</p>

<p>
Matching Functions:
</p>
<ul class="org-ul">
<li><b>Any()</b> - <code>.</code>: Matches any character but fails on <code>EOF</code>;</li>
<li><b>Literal(c)</b> - <code>"c"</code>: Fails if <code>c</code> doesn't match the character
under the input cursor;</li>
<li><b>Class(c[])</b> - <code>[abcd]</code>: Fail if none of the elements of <code>c[]</code>
match the character under the input cursor;</li>
<li><b>Range(ca, cb)</b> <code>[a-z]</code>: Fail if the current character under the
input cursor isn't between the characteres <code>ca</code> and <code>cb</code>;</li>
</ul>

<p>
Parsing Functions:
</p>
<ul class="org-ul">
<li><b>ZeroOrMore(fn)</b> - Star Operator (*): Execute <code>fn</code> indefinitely
until it fails.  All collected results are returned. It never
fails even if it fails in the first call;</li>
<li><b>OneOrMore(fn)</b> - Plus Operator (+): Execute <code>fn</code> once failing if
this first call fails. If the first call succeeds, then prepend
this result to the output of <code>ZeroOrMore(fn)</code></li>
<li><b>Option(fn)</b> - Option Operator (?): Return the result of <code>fn()</code> or
<code>null</code> if the call to <code>fn</code> fails.</li>
<li><b>Choice(fn[])</b> - Ordered Choice Operator (/): Iterate over <code>fn[]</code>,
and return the result of the first function that succeeds. It can
be seen as an OR operation.</li>
</ul>

<p>
Syntactic Predicate Functions:
</p>
<ul class="org-ul">
<li><b>Not(fn)</b> - <code>!</code>: Return true if <code>fn</code> fails and false if <code>fn</code>
succeeds;</li>
<li><b>And(fn)</b> - <code>&amp;</code>: The opposite of <b>Not</b> or <code>Not(Not(fn))</code>;</li>
</ul>

<p>
List Parsing Function:
</p>

<ul class="org-ul">
<li><b>Open()</b> - <code>{</code>: Return true if the element under the cursor is a
list;</li>
<li><b>Close()</b> - <code>}</code>: Return true if the currently open list has ended</li>
</ul>
</div>

<div class="outline-3">
<h3 id="scanner-interface">Scanner Interface</h3>
<div class="outline-text-3">
<p>
The parser that implements the PEG interface listed above is built
on top of a scanner that provides all the matching functions and
the ones that backtracks the input cursor.
</p>

<p>
This is the interface that the matching functions depend:
</p>
<ul class="org-ul">
<li><b>Scanner(input)</b>: Constructor that creates a new instance of the
scanner taking the input as a parameter;</li>
<li><b>Current()</b>: Return what's under the scanner's cursor;</li>
<li><b>EOS()</b>: Determine if the current element is the end of the input;</li>
<li><b>Error()</b>: Generate a parsing error;</li>
<li><b>Expect(e)</b>: Return the current element under the cursor if it
matches <code>e</code> or throw an error otherwise. Doesn't move input
cursor;</li>
<li><b>Match(e)</b>: Return the current element under the cursor if it
matches <code>e</code> and advance the cursor by the size of <code>e</code>;</li>
<li><b>Next()</b>: Advance the input cursor;</li>
</ul>

<p>
The parsing function <code>Choice</code> is also implemented in the scanner
because it needs direct control over the input cursor in order to
backtrack before a new option is attempted. E.g.:
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="org-comment-delimiter">// </span><span class="org-comment">Part of the JavaScript implementation of the scanner</span>
<span class="org-keyword">function</span> <span class="org-function-name">choice</span><span class="org-rainbow-delimiters-depth-1">(</span>...fns<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">const</span> <span class="org-variable-name">saved</span> = cursor; <span class="org-comment-delimiter">// </span><span class="org-comment">input cursor</span>
  <span class="org-keyword">for</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">const</span> <span class="org-variable-name">fn</span> of fns<span class="org-rainbow-delimiters-depth-2">)</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Once an alternative succeeds, all the other ones</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">are discarded.</span>
    <span class="org-keyword">try</span> <span class="org-rainbow-delimiters-depth-3">{</span> <span class="org-keyword">return</span> fn<span class="org-rainbow-delimiters-depth-4">()</span>; <span class="org-rainbow-delimiters-depth-3">}</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">If an alternative fails, the cursor is backtracked</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">to where it was in the beginning of the choice</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">operation.</span>
    <span class="org-keyword">catch</span> <span class="org-rainbow-delimiters-depth-3">(</span>e<span class="org-rainbow-delimiters-depth-3">)</span> <span class="org-rainbow-delimiters-depth-3">{</span> cursor = saved; <span class="org-rainbow-delimiters-depth-3">}</span>
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">If no alternatives succeed, the choice operation</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">fails.</span>
  <span class="org-keyword">throw</span> <span class="org-keyword">new</span> <span class="org-type">Error</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"None of the options matched"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
The syntactic predicate <code>Not</code> is implemented in the scanner as well
since it backtracks the input cursor after being executed in order
to provide infinite look-ahead.
</p>

<p>
The recursive descent parser generating grammar trees off PEG
grammars is built on top of the scanner interface and the PEG
functions (ZeroOrMore, Option, Choice, etc).  The separation of the
scanner interface from the implementation of the PEG functions
allowed the construction of the two different scanners: one for
text and another one for other data structures (lists).
</p>

<p>
To make things a bit less abstract, here's an example of each
scanner in action:
</p>
</div>

<div class="outline-4">
<h4 id="text-scanner">Text Scanner</h4>
<div class="outline-text-4">
<p>
The <code>match</code> function takes a string as its input:
</p>

<div class="org-src-container">
<pre class="src src-js">peg.pegc<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">`Number &lt;- [0-9]+`</span><span class="org-rainbow-delimiters-depth-1">)</span>.match<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">'1234'</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
which generates:
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'Number'</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">'1'</span>, <span class="org-string">'2'</span>, <span class="org-string">'3'</span>, <span class="org-string">'4'</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>
</div>
</div>

<div class="outline-4">
<h4 id="list-scanner">List Scanner</h4>
<div class="outline-text-4">
<p>
The <code>matchl</code> function takes a list as its input:
</p>

<div class="org-src-container">
<pre class="src src-js">peg.pegc<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">`</span>
<span class="org-string">  Numbers &lt;- { "Number" { Atom+ } }</span>
<span class="org-string">  Atom    &lt;- !{ .* } .</span>
<span class="org-string">`</span><span class="org-rainbow-delimiters-depth-1">)</span>.matchl<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">'Number'</span>, <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'1'</span>, <span class="org-string">'2'</span>, <span class="org-string">'3'</span>, <span class="org-string">'4'</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
which generates:
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'Numbers'</span>,
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">'Number'</span>,
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">'Atom'</span>, <span class="org-string">'1'</span><span class="org-rainbow-delimiters-depth-4">]</span>,
     <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">'Atom'</span>, <span class="org-string">'2'</span><span class="org-rainbow-delimiters-depth-4">]</span>,
     <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">'Atom'</span>, <span class="org-string">'3'</span><span class="org-rainbow-delimiters-depth-4">]</span>,
     <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">'Atom'</span>, <span class="org-string">'4'</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>
</div>
</div>
</div>

<div class="outline-3">
<h3 id="semantic-actions">Semantic Actions</h3>
<div class="outline-text-3">
<p>
After collecting the results from the matching operations and
nesting them following the grammar's structure, the PEG library can
also apply custom functions on the results of each rule
execution. E.g.:
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="org-comment-delimiter">// </span><span class="org-comment">JavaScript API for compiling a grammar and binding</span>
<span class="org-comment-delimiter">// </span><span class="org-comment">semantic actions to the generated parser</span>
<span class="org-keyword">const</span> <span class="org-variable-name">grammar</span> = <span class="org-string">`</span>
<span class="org-string">  Additive  &lt;- Multitive '+' Additive / Multitive</span>
<span class="org-string">  Multitive &lt;- Primary '*' Multitive / Primary</span>
<span class="org-string">  Primary   &lt;- '(' Additive ')' / Number</span>
<span class="org-string">  Number    &lt;- [0-9]+</span>
<span class="org-string">`</span>;
<span class="org-keyword">const</span> <span class="org-variable-name">parser</span> = peg.pegc<span class="org-rainbow-delimiters-depth-1">(</span>grammar<span class="org-rainbow-delimiters-depth-1">)</span>.bind<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-rainbow-delimiters-depth-2">{</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">The name of the action must correspond to the name</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">of the rule present in the grammar string.  The</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">function `visit` gives the control over when the</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">child nodes will be visited.  That allows executing</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">code before and after visiting happens.  This is</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">very useful during the code generation step on</span>
  <span class="org-comment-delimiter">// </span><span class="org-comment">the compiler.</span>
  Additive: <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">{</span> visit <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span> =&gt; <span class="org-rainbow-delimiters-depth-3">{</span>
    <span class="org-keyword">const</span> <span class="org-variable-name">v</span> = visit<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Ignore the string '+'</span>
    <span class="org-keyword">return</span> Array.isArray<span class="org-rainbow-delimiters-depth-4">(</span>v<span class="org-rainbow-delimiters-depth-4">)</span> ? v<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> + v<span class="org-rainbow-delimiters-depth-4">[</span>2<span class="org-rainbow-delimiters-depth-4">]</span> : v;
  <span class="org-rainbow-delimiters-depth-3">}</span>,
  Multitive: <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">{</span> visit <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span> =&gt; <span class="org-rainbow-delimiters-depth-3">{</span>
    <span class="org-keyword">const</span> <span class="org-variable-name">v</span> = visit<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Ignore the string '*'</span>
    <span class="org-keyword">return</span> Array.isArray<span class="org-rainbow-delimiters-depth-4">(</span>v<span class="org-rainbow-delimiters-depth-4">)</span> ? v<span class="org-rainbow-delimiters-depth-4">[</span>0<span class="org-rainbow-delimiters-depth-4">]</span> * v<span class="org-rainbow-delimiters-depth-4">[</span>2<span class="org-rainbow-delimiters-depth-4">]</span> : v;
  <span class="org-rainbow-delimiters-depth-3">}</span>,
  Primary: <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">{</span> visit <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span> =&gt; <span class="org-rainbow-delimiters-depth-3">{</span>
    <span class="org-keyword">const</span> <span class="org-variable-name">v</span> = visit<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Remove '(' and ')'</span>
    <span class="org-keyword">return</span> Array.isArray<span class="org-rainbow-delimiters-depth-4">(</span>v<span class="org-rainbow-delimiters-depth-4">)</span> ? v<span class="org-rainbow-delimiters-depth-4">[</span>1<span class="org-rainbow-delimiters-depth-4">]</span> : v;
  <span class="org-rainbow-delimiters-depth-3">}</span>,
  Number: <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-4">{</span> visit <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">)</span> =&gt; <span class="org-rainbow-delimiters-depth-3">{</span>
    <span class="org-keyword">const</span> <span class="org-variable-name">v</span> = visit<span class="org-rainbow-delimiters-depth-4">()</span>;
    <span class="org-keyword">const</span> <span class="org-variable-name">n</span> = Array.isArray<span class="org-rainbow-delimiters-depth-4">(</span>v<span class="org-rainbow-delimiters-depth-4">)</span> ? v.join<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">''</span><span class="org-rainbow-delimiters-depth-4">)</span> : v;
    <span class="org-keyword">return</span> parseInt<span class="org-rainbow-delimiters-depth-4">(</span>n, 10<span class="org-rainbow-delimiters-depth-4">)</span>;
  <span class="org-rainbow-delimiters-depth-3">}</span>
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">)</span>;

assertTrue<span class="org-rainbow-delimiters-depth-1">(</span>parser<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'42'</span><span class="org-rainbow-delimiters-depth-2">)</span> === 42<span class="org-rainbow-delimiters-depth-1">)</span>;
assertTrue<span class="org-rainbow-delimiters-depth-1">(</span>parser<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'40+2*5'</span><span class="org-rainbow-delimiters-depth-2">)</span> === 50<span class="org-rainbow-delimiters-depth-1">)</span>;
assertTrue<span class="org-rainbow-delimiters-depth-1">(</span>parser<span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">'(40+2)*5'</span><span class="org-rainbow-delimiters-depth-2">)</span> === 210<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
One of the effects of the infinite look-ahead, and the backtracking
specifically, is that the entire input has to be consumed before
deciding if the results are correct or not.  In other words, the
semantic action application happens as an entirely different
traversal <b>after</b> matching is successful.
</p>

<p>
This is explored in depth in the article <a href="https://ohmlang.github.io/pubs/dls2016/modular-semantic-actions.pdf">Modular Semantic Actions</a>
and the general suggestion this implementation follows is that the
semantic action application only happens after parsing finishes
successfully.
</p>
</div>
</div>
</div>

<div class="outline-2">
<h2 id="the-compiler">The Compiler</h2>
<div class="outline-text-2">
<p>
Now that we covered the PEG implementation, we're ready to tackle
the compilation process itself!
</p>
</div>

<div class="outline-3">
<h3 id="parsing-the-program-text">Parsing the program text</h3>
<div class="outline-text-3">
<p>
The first stage of the compiler <a href="https://github.com/clarete/effigy/blob/master/lang.peg">is a PEG grammar</a> that scan and
parse the program text and generate an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> (or AST
for short) off the syntax I made up.  The semantic actions
associated with that grammar join lists of characters into words,
convert lists of digits into numbers, tweak the shape of the AST to
make it less verbose and easier to be traversed and lastly help
overcoming two shortcomings of the PEG implementation:
</p>

<ol class="org-ol">
<li>Handle left recursion</li>
<li>Decide if a result should be wrapped into the name of its
parsing rule</li>
</ol>

<p>
There are a few documented ways to handling left recursion on
PEGs. The nicest one I found is via <b><b>Bounded Left Recursion</b></b>.
That approach is described in depth in the article <a href="http://www.inf.puc-rio.br/~roberto/docs/sblp2012.pdf">Left Recursion
in Parsing Expression Grammars</a>, but I didn't get to fully implement
it, so I put it aside to focus on getting to a working compiler.
</p>

<p>
The second problem of wrapping captured values with the rule name
or not could have been fixed by adding a new operator to the PEG
implementation and resolved at the grammar level.  But instead I
chose to implement that using semantic actions since the code
needed was simple although a bit verbose.  But everything else
worked out pretty smoothly.  That's enough of background, let's
look at an example. The following code:
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-keyword">fn</span> <span class="org-function-name">sum</span><span class="org-rainbow-delimiters-depth-1">(</span>a, b<span class="org-rainbow-delimiters-depth-1">)</span> a + b
print<span class="org-rainbow-delimiters-depth-1">(</span>sum<span class="org-rainbow-delimiters-depth-2">(</span>2, 3<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
should generate the following AST:
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'Module'</span>,
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'Statement'</span>,
    <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">'Function'</span>,
     <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-string">'sum'</span>,
      <span class="org-rainbow-delimiters-depth-6">[</span><span class="org-string">'Params'</span>, <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-rainbow-delimiters-depth-8">[</span><span class="org-string">'Param'</span>, <span class="org-string">'a'</span><span class="org-rainbow-delimiters-depth-8">]</span>, <span class="org-rainbow-delimiters-depth-8">[</span><span class="org-string">'Param'</span>, <span class="org-string">'b'</span><span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">]</span>,
      <span class="org-rainbow-delimiters-depth-6">[</span><span class="org-string">'Code'</span>,
       <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-string">'Statement'</span>,
        <span class="org-rainbow-delimiters-depth-8">[</span><span class="org-string">'BinOp'</span>, <span class="org-rainbow-delimiters-depth-9">[</span><span class="org-string">'Load'</span>, <span class="org-string">'a'</span><span class="org-rainbow-delimiters-depth-9">]</span>, <span class="org-string">'+'</span>, <span class="org-rainbow-delimiters-depth-9">[</span><span class="org-string">'Load'</span>, <span class="org-string">'b'</span><span class="org-rainbow-delimiters-depth-9">]</span><span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">]</span>,
   <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'Statement'</span>,
    <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">'Call'</span>,
     <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-rainbow-delimiters-depth-6">[</span><span class="org-string">'Load'</span>, <span class="org-string">'print'</span><span class="org-rainbow-delimiters-depth-6">]</span>,
      <span class="org-rainbow-delimiters-depth-6">[</span><span class="org-rainbow-delimiters-depth-7">[</span><span class="org-string">'Call'</span>,
        <span class="org-rainbow-delimiters-depth-8">[</span><span class="org-rainbow-delimiters-depth-9">[</span><span class="org-string">'Load'</span>, <span class="org-string">'sum'</span> <span class="org-rainbow-delimiters-depth-9">]</span>,
         <span class="org-rainbow-delimiters-depth-9">[</span><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'Value'</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">'Number'</span>, 2<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>,
          <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'Value'</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">'Number'</span>, 3<span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span><span class="org-rainbow-delimiters-depth-9">]</span><span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
Notice that <code>fn sum(a, b) { return a + b }</code> outputs the same tree
as <code>fn sum(a, b) a + b</code>.  Code blocks accept either a single
statement or a list of statements within curly brackets (<code>{}</code>).
</p>
</div>
</div>

<div class="outline-3">
<h3 id="mapping-out-scope-rules">Mapping out scope rules</h3>
<div class="outline-text-3">
<p>
After generating the AST during the text parsing phase, we need to
go through an additional step before translating the AST into
<i>bytecode</i>.  The scope of every variable needs to be mapped into
one of the three categories:
</p>

<ol class="org-ol">
<li>Local variables</li>
<li>Global variables</li>
<li>Free variables</li>
</ol>

<p>
Let's look at the following code snippet to talk about it:
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-keyword">fn</span> <span class="org-function-name">plus_n</span><span class="org-rainbow-delimiters-depth-1">(</span>x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">fn</span><span class="org-rainbow-delimiters-depth-1">(</span>y<span class="org-rainbow-delimiters-depth-1">)</span> x + y
plus_five = plus_n<span class="org-rainbow-delimiters-depth-1">(</span>5<span class="org-rainbow-delimiters-depth-1">)</span>
print<span class="org-rainbow-delimiters-depth-1">(</span>plus_five<span class="org-rainbow-delimiters-depth-2">(</span>2<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment"># Equals 7</span>
</pre>
</div>

<p>
In the example above, <code>x</code> is declared at the scope created by the
<code>plus_n</code> function and must be available when it's summed to <code>y</code>
within the scope of the anonymous function.  The variable <code>y</code> is a
local variable since it gets created and destroyed within the same
scope, but <code>x</code> is a free variable.
</p>

<p>
Free variables are variables available in the lexical scope that
must be kept around to be used when the scope that declared these
variables isn't around anymore.
</p>

<p>
Global variables seem to exist in Python for performance reasons.
The Python interpreter skips look ups on the local scope for names
that are known to be available in the module scope or within the
built-in module, like the name <code>print</code> in the example above.
</p>

<p>
The process of mapping variables into the aforementioned categories
is done by traversing the AST using a <a href="https://github.com/clarete/effigy/blob/master/lang.tr">second PEG grammar</a> for
parsing lists instead of a stream of characters.  During that
process, a symbol table is built and the AST is annotated with
information that allows the translation phase to look up each
variable in the symbol table.
</p>

<p>
The following Effigy snippet
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-keyword">fn</span> <span class="org-function-name">plus_n</span><span class="org-rainbow-delimiters-depth-1">(</span>x<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-keyword">fn</span> <span class="org-rainbow-delimiters-depth-1">(</span>y<span class="org-rainbow-delimiters-depth-1">)</span> x + y
</pre>
</div>

<p>
generates an annotated AST that looks like this:
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'Module'</span>,
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'Statement'</span>,
    <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">'Function'</span>,
     <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-rainbow-delimiters-depth-6">[</span><span class="org-string">'ScopeId'</span>, 2<span class="org-rainbow-delimiters-depth-6">]</span>, <span class="org-string">'plus_n'</span>,
      <span class="org-rainbow-delimiters-depth-6">[</span><span class="org-string">'Params'</span>, <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-rainbow-delimiters-depth-8">[</span><span class="org-string">'Param'</span>, <span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">]</span>,
      <span class="org-rainbow-delimiters-depth-6">[</span><span class="org-string">'Code'</span>,
       <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-string">'Statement'</span>,
        <span class="org-rainbow-delimiters-depth-8">[</span><span class="org-string">'Lambda'</span>,
         <span class="org-rainbow-delimiters-depth-9">[</span><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'ScopeId'</span>, 1<span class="org-rainbow-delimiters-depth-1">]</span>,
          <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'Params'</span>, <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'Param'</span>, <span class="org-string">'y'</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>,
          <span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'Code'</span>,
           <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">'Statement'</span>,
            <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'BinOp'</span>,
             <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">'Load'</span>, <span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-4">]</span>, <span class="org-string">'+'</span>, <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-string">'Load'</span>, <span class="org-string">'y'</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span><span class="org-rainbow-delimiters-depth-9">]</span><span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
The <code>ScopeId</code> nodes introduced within each scope are used during
the compilation process to look up the nth entry within the current
scope of the symbol table.  Here's a simplified view of the list of
fields a symbol table for the above snippet contains:
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-rainbow-delimiters-depth-2">{</span>
  node: <span class="org-string">'module'</span>,
  fast: <span class="org-rainbow-delimiters-depth-3">[]</span>,
  deref: <span class="org-rainbow-delimiters-depth-3">[]</span>,
  globals: <span class="org-rainbow-delimiters-depth-3">[]</span>,
  children: <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-rainbow-delimiters-depth-4">{</span>
    node: <span class="org-string">'function'</span>,
    fast: <span class="org-rainbow-delimiters-depth-5">[]</span>,
    deref: <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-5">]</span>,
    globals: <span class="org-rainbow-delimiters-depth-5">[]</span>,
    children: <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-rainbow-delimiters-depth-6">{</span>
      node: <span class="org-string">'lambda'</span>,
      fast: <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-string">'y'</span><span class="org-rainbow-delimiters-depth-7">]</span>,
      deref: <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-string">'x'</span><span class="org-rainbow-delimiters-depth-7">]</span>,
      globals: <span class="org-rainbow-delimiters-depth-7">[]</span>,
      children: <span class="org-rainbow-delimiters-depth-7">[]</span>
    <span class="org-rainbow-delimiters-depth-6">}</span><span class="org-rainbow-delimiters-depth-5">]</span>
  <span class="org-rainbow-delimiters-depth-4">}</span><span class="org-rainbow-delimiters-depth-3">]</span>
<span class="org-rainbow-delimiters-depth-2">}</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
One last thing that might be interesting to mention about scopes is
that Python tries to figure out if a variable is a free variable by
comparing where it was assigned and where it was used.  If it is
assigned in the same scope that it's being used, it is a local
variable.  If it is assigned in an enclosing scope, it is a free
variable.  If one needs to reassign a free variable in an inner
scope, the <a href="https://www.python.org/dev/peps/pep-3104/">nonlocal</a> keyword is required to inform the Python
compiler that the assignment isn't local.
</p>

<p>
I chose a slightly different way to allow reassigning free
variables from enclosing scopes.  Effigy provides the <code>let</code> keyword
to mark variables as free variables at the outer scope:
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-keyword">fn</span> <span class="org-function-name">f</span><span class="org-rainbow-delimiters-depth-1">(</span>input<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">let</span> <span class="org-variable-name">c</span> = 0
  <span class="org-keyword">fn</span> <span class="org-function-name">next</span><span class="org-rainbow-delimiters-depth-2">()</span> <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-variable-name">value</span> = input<span class="org-rainbow-delimiters-depth-3">[</span>c<span class="org-rainbow-delimiters-depth-3">]</span>
    <span class="org-variable-name">c</span> = c + 1
    <span class="org-keyword">return</span> value
  <span class="org-rainbow-delimiters-depth-2">}</span>
  <span class="org-keyword">return</span> next
<span class="org-rainbow-delimiters-depth-1">}</span>
cursor = f<span class="org-rainbow-delimiters-depth-1">(</span><span class="org-string">"word"</span><span class="org-rainbow-delimiters-depth-1">)</span>
print<span class="org-rainbow-delimiters-depth-1">(</span>cursor<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment"># prints "w"</span>
print<span class="org-rainbow-delimiters-depth-1">(</span>cursor<span class="org-rainbow-delimiters-depth-2">()</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment"># prints "o"</span>
</pre>
</div>

<p>
I haven't used Effigy enough to know if that was a good choice
though :)
</p>

<p>
I bet there might be a way of bundling the symbol table and
generating the code in a single pass, but that wasn't the route I
took.  Quite a few decisions I made for handling variable scope
were inspired by the beautiful write up <a href="https://codewords.recurse.com/issues/seven/dragon-taming-with-tailbiter-a-bytecode-compiler">Dragon taming with
Tailbiter, a bytecode compiler for Python</a> and that's the route that
Darius Bacon took on his experiment.  I highly recommend reading
that post.  It's enlightening and might help understanding the rest
of this post since I won't get into too many details about how
Python itself woks.
</p>
</div>
</div>

<div class="outline-3">
<h3 id="output-format">Output format</h3>
<div class="outline-text-3">
<p>
Once the AST is annotated by the scope traversal step, it is ready
to be fed once again into the <a href="https://github.com/clarete/effigy/blob/master/lang.tr">second PEG grammar</a> to be traversed
once more, but now with the intent of driving the assembler to
generate code.  In this step, the functions (and modules) in Effigy
are assembled into <a href="https://docs.python.org/3.7/library/dis.html#python-bytecode-instructions"><i>bytecode</i> instructions</a> and bundled into <a href="https://docs.python.org/3/c-api/code.html">Code
objects</a>.
</p>

<p>
Instances of Code objects store <i>bytecode</i> within the <code>co_code</code>
attribute.  They also store metadata, like the number of arguments
a function receives (<code>co_argcount</code>) or the number of local
variables (<code>co_nlocals</code>) for example.  The other very important
data Code objects store is tables with values.  There's one table
for literal values (<code>co_consts</code>), one for local variables
(<code>co_varnames</code>), one for free variables (<code>co_freevars</code>) and one for
global variables (<code>co_names</code>).
</p>

<p>
All these tables are indexed with integers and carry <code>PyObject</code>
instances within them.  And since functions themselves are
<code>PyObject</code> instances, Code object is a recursive data type.
</p>

<p>
When the compiler enters a new scope, a Code object instance is
created, <i>bytecode</i> is generated and tables are filled with data.
When the compiler leaves a scope, the Code object instance is
returned and bundled within the outer Code object, up until the
module scope, which is the top one.
</p>

<p>
When code generation is done, the Code object is written into a
buffer and a header with the following four 32 bit fields is built:
</p>

<ul class="org-ul">
<li>magic number</li>
<li><a href="https://www.python.org/dev/peps/pep-0552/">PEP-552</a> field (Allows deterministic builds of <code>.pyc</code> files)</li>
<li>Modified Date</li>
<li>Size of the code buffer</li>
</ul>

<p>
The last step is to write the header and the code buffer into a
<code>.pyc</code> file.
</p>
</div>
</div>

<div class="outline-3">
<h3 id="code-generation">Code Generation</h3>
<div class="outline-text-3">
<p>
Generating the assembly code for filling in the <code>co_code</code>
attributes of Code objects is certainly the biggest task performed
by the compiler.  Let's take a look at how the compiler would
generate code for the following expression <code>result = 2 + 3 * 4</code>.
</p>

<p>
First the following AST is generated:
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-rainbow-delimiters-depth-1">[</span><span class="org-string">'Module'</span>,
  <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">'Statement'</span>,
   <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'Assignment'</span>,
    <span class="org-rainbow-delimiters-depth-4">[</span><span class="org-rainbow-delimiters-depth-5">[</span><span class="org-string">'BinOp'</span>,
      <span class="org-rainbow-delimiters-depth-6">[</span><span class="org-string">'Value'</span>, <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-string">'Number'</span>, 2<span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">]</span>,
      <span class="org-string">'+'</span>,
      <span class="org-rainbow-delimiters-depth-6">[</span><span class="org-string">'BinOp'</span>,
       <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-string">'Value'</span>, <span class="org-rainbow-delimiters-depth-8">[</span><span class="org-string">'Number'</span>, 3<span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">]</span>,
       <span class="org-string">'*'</span>,
       <span class="org-rainbow-delimiters-depth-7">[</span><span class="org-string">'Value'</span>, <span class="org-rainbow-delimiters-depth-8">[</span><span class="org-string">'Number'</span>, 4<span class="org-rainbow-delimiters-depth-8">]</span><span class="org-rainbow-delimiters-depth-7">]</span><span class="org-rainbow-delimiters-depth-6">]</span><span class="org-rainbow-delimiters-depth-5">]</span>,
     <span class="org-rainbow-delimiters-depth-5">[</span><span class="org-string">'Store'</span>, <span class="org-string">'result'</span><span class="org-rainbow-delimiters-depth-5">]</span><span class="org-rainbow-delimiters-depth-4">]</span><span class="org-rainbow-delimiters-depth-3">]</span><span class="org-rainbow-delimiters-depth-2">]</span><span class="org-rainbow-delimiters-depth-1">]</span>
</pre>
</div>

<p>
When the translation phase takes the above tree as input, it
outputs the following Code object:
</p>

<div class="org-src-container">
<pre class="src src-effigy"><span class="org-rainbow-delimiters-depth-1">{</span>
  constants: <span class="org-rainbow-delimiters-depth-2">[</span>2, 3, 4, <span class="org-constant">null</span><span class="org-rainbow-delimiters-depth-2">]</span>,
  names: <span class="org-rainbow-delimiters-depth-2">[</span><span class="org-string">'result'</span><span class="org-rainbow-delimiters-depth-2">]</span>,
  instructions: <span class="org-rainbow-delimiters-depth-2">[</span>
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'load-const'</span>, 0<span class="org-rainbow-delimiters-depth-3">]</span>,
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'load-const'</span>, 1<span class="org-rainbow-delimiters-depth-3">]</span>,
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'load-const'</span>, 2<span class="org-rainbow-delimiters-depth-3">]</span>,
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'binary-multiply'</span><span class="org-rainbow-delimiters-depth-3">]</span>,
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'binary-add'</span><span class="org-rainbow-delimiters-depth-3">]</span>,
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'store-name'</span>, 0<span class="org-rainbow-delimiters-depth-3">]</span>,
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'load-const'</span>, 3<span class="org-rainbow-delimiters-depth-3">]</span>,
    <span class="org-rainbow-delimiters-depth-3">[</span><span class="org-string">'return-value'</span><span class="org-rainbow-delimiters-depth-3">]</span>
  <span class="org-rainbow-delimiters-depth-2">]</span>,
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Notice that the <code>load-const</code> instructions have an index of the
<code>constants</code> table as its parameter.  That's how the Python Virtual
Machine figures out which constant is being referred and what value
to push to the stack.  The <code>binary-multiply</code> and <code>binary-add</code>
instructions pop data from the stack, perform their respective
operations, and then push the result back to the stack.  The
instruction <code>store-name</code> pops the value left by <code>binary-add</code> off
the stack and save it into the variable referenced in the <code>names</code>
table.  The last <code>load-const</code> is there because all Code objects
must return.  And when a return statement isn't explicitly provided
(like in module scopes), <code>null</code> (which represents Python's <code>None</code>)
is returned.
</p>

<div class="note">
<p>
If you want to check out all the other cases that effigy can
handle, <a href="https://github.com/clarete/effigy/blob/master/spec/lang.spec.js">look at the specs</a> I wrote while I was putting the compiler
together.
</p>

</div>

<p>
It's interesting to mention that the semantic actions for AST nodes
that interact with the values tables in the Code object have two
jobs.  They have to either save or load values from the tables and
also emit instructions.  The semantic action for the <code>Number</code> nodes
is a good example to shown how it's done:
</p>

<div class="org-src-container">
<pre class="src src-js"><span class="org-rainbow-delimiters-depth-1">{</span>
  Number: <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-rainbow-delimiters-depth-3">{</span> visit <span class="org-rainbow-delimiters-depth-3">}</span><span class="org-rainbow-delimiters-depth-2">)</span> =&gt; <span class="org-rainbow-delimiters-depth-2">{</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">Visit the actual value to join the digits and</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">convert to a JavaScript integer</span>
    <span class="org-keyword">const</span> <span class="org-variable-name">value</span> = visit<span class="org-rainbow-delimiters-depth-3">()[</span>1<span class="org-rainbow-delimiters-depth-3">]</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Push the value to the constants table if it</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">isn't there yet</span>
    <span class="org-keyword">const</span> <span class="org-variable-name">index</span> = addToTable<span class="org-rainbow-delimiters-depth-3">(</span>attr<span class="org-rainbow-delimiters-depth-4">(</span><span class="org-string">'constants'</span><span class="org-rainbow-delimiters-depth-4">)</span>, value<span class="org-rainbow-delimiters-depth-3">)</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">Emit the instruction with the index of the</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">constant as the parameter to the instruction</span>
    emit<span class="org-rainbow-delimiters-depth-3">(</span><span class="org-string">'load-const'</span>, index<span class="org-rainbow-delimiters-depth-3">)</span>;
  <span class="org-rainbow-delimiters-depth-2">}</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div class="outline-3">
<h3 id="assemble-binary-data">Assemble binary data</h3>
<div class="outline-text-3">
<p>
Besides emitting instructions, the assembler has to support
back-patching of values that were not known ahead of time.  Three
little functions on the assembler's interface allowed that to
happen:
</p>

<ul class="org-ul">
<li><code>pos()</code>: Return the index of the current instruction;</li>
<li><code>ref()</code>: Push the index of the current instruction to a list of
labels and return the index of the label;</li>
<li><code>fix(label, value)</code>: Replace the instruction within <code>label</code> with
<code>value</code>.</li>
</ul>

<p>
For the sake of completion, here are the other functions that
comprise the assembler's interface (already mentioned on previous
sections):
</p>

<ul class="org-ul">
<li><code>enter()</code>: Enter a new scope, creating a new Code object
instance;</li>
<li><code>leave()</code>: Return the Code object built for the current scope and
set the enclosing scope as the current one;</li>
<li><code>emit(opcode, argument)</code>: Append instruction to the <code>co_code</code>
attribute of the current Code Object</li>
<li><code>attr(name, value=undefined)</code>: Helper function for reading or
writing a value to one of the values tables of the current scope;</li>
</ul>

<p>
To not have to deal with binary code the whole time I worked on
this toy, I wrote a dummy implementation used for debug purposes
that contained actual JavaScript lists, strings and numbers.
</p>

<p>
After validating that the code generation produced what I intended,
I just swapped assemblers and used the one that actually knew how
to marshal JavaScript objects into the format that the Python
Virtual Machine could understand.
</p>

<p>
The part of the assembler that marshals JavaScript objects into the
binary format that the Python Virtual Machine can read is mostly a
translation of the code under <a href="https://github.com/python/cpython/blob/3.7/Python/marshal.c">Python/marshal.c</a> to JavaScript.
</p>
</div>
</div>
</div>

<div class="outline-2">
<h2 id="final-thoughts">Final Thoughts</h2>
<div class="outline-text-2">
<p>
As you must have noticed, there's way more information about the
architecture of the compiler and the PEG implementation than about
how Python works.  That's sort of intentional, because my first goal
with this little experiment was to learn more about compilers and
since Python is the language I know the most, I used knowledge I
already had to put it together.  That being said, I still learned a
whole lot about Python itself on this short journey.  Python is
indeed a fascinating language and its simplicity matches the beauty
of a poem.
</p>

<p>
Although the compiler actually produces files that can be executed
by Python, there's a whole lot missing that I didn't even intend to
cover. Here are a few:
</p>

<ol class="org-ol">
<li>The Effigy compiler has the worst error reporting you can
possibly imagine.  If an input has a syntax error, it will only
give you the index of the character that it can't recognize.  If
the error is on the translation after the syntax tree has been
built, you're going to have to print out the AST and figure it
out yourself.</li>

<li>The Effigy language doesn't support lots of very useful features
provided by Python and required for a minimally comfortable
programming experience, like declaring classes, importing other
modules, creating dictionaries with literals (you can still call
the <code>dict()</code> function though :D).</li>

<li>As I mentioned before, the code generated isn't optimized in any
way, so it will most likely be way slower than code generated by
the Python compiler. It's still something I want to do in another
exercise, but I bet Effigy won't ever see that improvement.</li>
</ol>

<p>
Although this was just a simple exercise completely focused in
learning more about programming languages and having fun, I am
curious to hear what you think. If this article or Effigy sparkled
your curiosity, don't hesitate in reaching out!  Send me an email or
find me on the <a href="https://freenode.net/">freenode</a> IRC network (I'm usually hanging out on the
<code>#emacs</code> channel).
</p>
</div>
</div>

  </div>

      </div>
    </div>

    <div class="footer">
      
        <div class="bg">
          <div class="container">
            &#169; Lincoln Clarete &mdash; All written content on this
            website reflects my personal opinion and it's available
            under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>
          </div>
        </div>
      
    </div>
  </body>
</html>
